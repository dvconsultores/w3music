{"version":3,"sources":["webpack:////Users/mariaarevalo/node_modules/@firebase/component/dist/esm/index.esm2017.js","webpack:////Users/mariaarevalo/node_modules/@firebase/firestore-compat/dist/index.esm2017.js"],"names":["Component","name","instanceFactory","type","this","multipleInstances","serviceProps","instantiationMode","onInstanceCreated","mode","props","callback","DEFAULT_ENTRY_NAME","Provider","container","component","instances","Map","instancesDeferred","instancesOptions","onInitCallbacks","identifier","normalizedIdentifier","normalizeInstanceIdentifier","has","deferred","set","isInitialized","shouldAutoInitialize","instance","getOrInitializeService","instanceIdentifier","resolve","e","get","promise","options","_a","optional","Error","isComponentEager","instanceDeferred","entries","delete","services","Array","from","values","Promise","all","filter","service","map","INTERNAL","_delete","opts","isComponentSet","normalizedDeferredIdentifier","existingCallbacks","Set","add","existingInstance","callbacks","normalizeIdentifierForFactory","invokeOnInitCallbacks","undefined","ComponentContainer","providers","provider","getProvider","setComponent","addComponent","version","validateSetOptions","methodName","merge","mergeFields","assertUint8ArrayAvailable","Uint8Array","assertBase64Available","Blob","_delegate","base64","fromBase64String","array","fromUint8Array","toBase64","toUint8Array","other","isEqual","isPartialObserver","obj","implementsAnyMethods","methods","object","method","IndexedDbPersistenceProvider","firestore","forceOwnership","Firestore","databaseIdOrApp","_persistenceProvider","terminate","_appCompat","_databaseId","settingsLiteral","currentSettings","_getSettings","host","Object","assign","_setSettings","port","settings","synchronizeTabs","experimentalForceOwningTab","enableMultiTabIndexedDbPersistence","enableIndexedDbPersistence","clearIndexedDbPersistence","_removeServiceInstance","arg","pathString","CollectionReference","replaceFunctionName","DocumentReference","collectionId","Query","updateFunction","transaction","Transaction","WriteBatch","mutations","bundleData","then","expQuery","UserDataWriter","super","bytes","key","convertDocumentKey","forKey","setLogLevel","level","_firestore","_userDataWriter","documentRef","ref","castReference","result","DocumentSnapshot","_key","_document","metadata","converter","data","dataOrField","value","moreFieldsAndValues","arguments","length","update","commit","FirestoreDataConverter","snapshot","expSnapshot","fromFirestore","QueryDocumentSnapshot","modelObject","toFirestore","converterMapByFirestore","INSTANCES","untypedConverterByConverter","WeakMap","path","canonicalString","id","parent","fieldOrUpdateData","args","extractSnapshotOptions","observer","wrapObserver","snap","source","withConverter","getInstance","original","updated","message","replace","wrapper","_b","userObserver","next","error","complete","val","bind","exists","fieldPath","opStr","directionStr","n","query","QuerySnapshot","_snapshot","DocumentChange","doc","oldIndex","newIndex","size","empty","docs","docChanges","docChange","thisArg","forEach","call","docRef","documentPath","FieldPath","fieldNames","keyField","_internalPath","FieldValue","delegate","_methodName","elements","firestoreNamespace","GeoPoint","Timestamp","CACHE_SIZE_UNLIMITED","configureForFirebase","firebase","firestoreFactory","registerComponent","app","getImmediate","firestoreExp","setServiceProps","registerFirestore","registerVersion"],"mappings":"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","file":"js/chunk-3d321085.51bb58aa.js","sourcesContent":["import { Deferred } from '@firebase/util';\n\n/**\r\n * Component for service name T, e.g. `auth`, `auth-internal`\r\n */\r\nclass Component {\r\n    /**\r\n     *\r\n     * @param name The public service name, e.g. app, auth, firestore, database\r\n     * @param instanceFactory Service factory responsible for creating the public interface\r\n     * @param type whether the service provided by the component is public or private\r\n     */\r\n    constructor(name, instanceFactory, type) {\r\n        this.name = name;\r\n        this.instanceFactory = instanceFactory;\r\n        this.type = type;\r\n        this.multipleInstances = false;\r\n        /**\r\n         * Properties to be added to the service namespace\r\n         */\r\n        this.serviceProps = {};\r\n        this.instantiationMode = \"LAZY\" /* InstantiationMode.LAZY */;\r\n        this.onInstanceCreated = null;\r\n    }\r\n    setInstantiationMode(mode) {\r\n        this.instantiationMode = mode;\r\n        return this;\r\n    }\r\n    setMultipleInstances(multipleInstances) {\r\n        this.multipleInstances = multipleInstances;\r\n        return this;\r\n    }\r\n    setServiceProps(props) {\r\n        this.serviceProps = props;\r\n        return this;\r\n    }\r\n    setInstanceCreatedCallback(callback) {\r\n        this.onInstanceCreated = callback;\r\n        return this;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst DEFAULT_ENTRY_NAME = '[DEFAULT]';\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Provider for instance for service name T, e.g. 'auth', 'auth-internal'\r\n * NameServiceMapping[T] is an alias for the type of the instance\r\n */\r\nclass Provider {\r\n    constructor(name, container) {\r\n        this.name = name;\r\n        this.container = container;\r\n        this.component = null;\r\n        this.instances = new Map();\r\n        this.instancesDeferred = new Map();\r\n        this.instancesOptions = new Map();\r\n        this.onInitCallbacks = new Map();\r\n    }\r\n    /**\r\n     * @param identifier A provider can provide mulitple instances of a service\r\n     * if this.component.multipleInstances is true.\r\n     */\r\n    get(identifier) {\r\n        // if multipleInstances is not supported, use the default name\r\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\r\n        if (!this.instancesDeferred.has(normalizedIdentifier)) {\r\n            const deferred = new Deferred();\r\n            this.instancesDeferred.set(normalizedIdentifier, deferred);\r\n            if (this.isInitialized(normalizedIdentifier) ||\r\n                this.shouldAutoInitialize()) {\r\n                // initialize the service if it can be auto-initialized\r\n                try {\r\n                    const instance = this.getOrInitializeService({\r\n                        instanceIdentifier: normalizedIdentifier\r\n                    });\r\n                    if (instance) {\r\n                        deferred.resolve(instance);\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    // when the instance factory throws an exception during get(), it should not cause\r\n                    // a fatal error. We just return the unresolved promise in this case.\r\n                }\r\n            }\r\n        }\r\n        return this.instancesDeferred.get(normalizedIdentifier).promise;\r\n    }\r\n    getImmediate(options) {\r\n        var _a;\r\n        // if multipleInstances is not supported, use the default name\r\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(options === null || options === void 0 ? void 0 : options.identifier);\r\n        const optional = (_a = options === null || options === void 0 ? void 0 : options.optional) !== null && _a !== void 0 ? _a : false;\r\n        if (this.isInitialized(normalizedIdentifier) ||\r\n            this.shouldAutoInitialize()) {\r\n            try {\r\n                return this.getOrInitializeService({\r\n                    instanceIdentifier: normalizedIdentifier\r\n                });\r\n            }\r\n            catch (e) {\r\n                if (optional) {\r\n                    return null;\r\n                }\r\n                else {\r\n                    throw e;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            // In case a component is not initialized and should/can not be auto-initialized at the moment, return null if the optional flag is set, or throw\r\n            if (optional) {\r\n                return null;\r\n            }\r\n            else {\r\n                throw Error(`Service ${this.name} is not available`);\r\n            }\r\n        }\r\n    }\r\n    getComponent() {\r\n        return this.component;\r\n    }\r\n    setComponent(component) {\r\n        if (component.name !== this.name) {\r\n            throw Error(`Mismatching Component ${component.name} for Provider ${this.name}.`);\r\n        }\r\n        if (this.component) {\r\n            throw Error(`Component for ${this.name} has already been provided`);\r\n        }\r\n        this.component = component;\r\n        // return early without attempting to initialize the component if the component requires explicit initialization (calling `Provider.initialize()`)\r\n        if (!this.shouldAutoInitialize()) {\r\n            return;\r\n        }\r\n        // if the service is eager, initialize the default instance\r\n        if (isComponentEager(component)) {\r\n            try {\r\n                this.getOrInitializeService({ instanceIdentifier: DEFAULT_ENTRY_NAME });\r\n            }\r\n            catch (e) {\r\n                // when the instance factory for an eager Component throws an exception during the eager\r\n                // initialization, it should not cause a fatal error.\r\n                // TODO: Investigate if we need to make it configurable, because some component may want to cause\r\n                // a fatal error in this case?\r\n            }\r\n        }\r\n        // Create service instances for the pending promises and resolve them\r\n        // NOTE: if this.multipleInstances is false, only the default instance will be created\r\n        // and all promises with resolve with it regardless of the identifier.\r\n        for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {\r\n            const normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\r\n            try {\r\n                // `getOrInitializeService()` should always return a valid instance since a component is guaranteed. use ! to make typescript happy.\r\n                const instance = this.getOrInitializeService({\r\n                    instanceIdentifier: normalizedIdentifier\r\n                });\r\n                instanceDeferred.resolve(instance);\r\n            }\r\n            catch (e) {\r\n                // when the instance factory throws an exception, it should not cause\r\n                // a fatal error. We just leave the promise unresolved.\r\n            }\r\n        }\r\n    }\r\n    clearInstance(identifier = DEFAULT_ENTRY_NAME) {\r\n        this.instancesDeferred.delete(identifier);\r\n        this.instancesOptions.delete(identifier);\r\n        this.instances.delete(identifier);\r\n    }\r\n    // app.delete() will call this method on every provider to delete the services\r\n    // TODO: should we mark the provider as deleted?\r\n    async delete() {\r\n        const services = Array.from(this.instances.values());\r\n        await Promise.all([\r\n            ...services\r\n                .filter(service => 'INTERNAL' in service) // legacy services\r\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n                .map(service => service.INTERNAL.delete()),\r\n            ...services\r\n                .filter(service => '_delete' in service) // modularized services\r\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n                .map(service => service._delete())\r\n        ]);\r\n    }\r\n    isComponentSet() {\r\n        return this.component != null;\r\n    }\r\n    isInitialized(identifier = DEFAULT_ENTRY_NAME) {\r\n        return this.instances.has(identifier);\r\n    }\r\n    getOptions(identifier = DEFAULT_ENTRY_NAME) {\r\n        return this.instancesOptions.get(identifier) || {};\r\n    }\r\n    initialize(opts = {}) {\r\n        const { options = {} } = opts;\r\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(opts.instanceIdentifier);\r\n        if (this.isInitialized(normalizedIdentifier)) {\r\n            throw Error(`${this.name}(${normalizedIdentifier}) has already been initialized`);\r\n        }\r\n        if (!this.isComponentSet()) {\r\n            throw Error(`Component ${this.name} has not been registered yet`);\r\n        }\r\n        const instance = this.getOrInitializeService({\r\n            instanceIdentifier: normalizedIdentifier,\r\n            options\r\n        });\r\n        // resolve any pending promise waiting for the service instance\r\n        for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {\r\n            const normalizedDeferredIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\r\n            if (normalizedIdentifier === normalizedDeferredIdentifier) {\r\n                instanceDeferred.resolve(instance);\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n    /**\r\n     *\r\n     * @param callback - a function that will be invoked  after the provider has been initialized by calling provider.initialize().\r\n     * The function is invoked SYNCHRONOUSLY, so it should not execute any longrunning tasks in order to not block the program.\r\n     *\r\n     * @param identifier An optional instance identifier\r\n     * @returns a function to unregister the callback\r\n     */\r\n    onInit(callback, identifier) {\r\n        var _a;\r\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\r\n        const existingCallbacks = (_a = this.onInitCallbacks.get(normalizedIdentifier)) !== null && _a !== void 0 ? _a : new Set();\r\n        existingCallbacks.add(callback);\r\n        this.onInitCallbacks.set(normalizedIdentifier, existingCallbacks);\r\n        const existingInstance = this.instances.get(normalizedIdentifier);\r\n        if (existingInstance) {\r\n            callback(existingInstance, normalizedIdentifier);\r\n        }\r\n        return () => {\r\n            existingCallbacks.delete(callback);\r\n        };\r\n    }\r\n    /**\r\n     * Invoke onInit callbacks synchronously\r\n     * @param instance the service instance`\r\n     */\r\n    invokeOnInitCallbacks(instance, identifier) {\r\n        const callbacks = this.onInitCallbacks.get(identifier);\r\n        if (!callbacks) {\r\n            return;\r\n        }\r\n        for (const callback of callbacks) {\r\n            try {\r\n                callback(instance, identifier);\r\n            }\r\n            catch (_a) {\r\n                // ignore errors in the onInit callback\r\n            }\r\n        }\r\n    }\r\n    getOrInitializeService({ instanceIdentifier, options = {} }) {\r\n        let instance = this.instances.get(instanceIdentifier);\r\n        if (!instance && this.component) {\r\n            instance = this.component.instanceFactory(this.container, {\r\n                instanceIdentifier: normalizeIdentifierForFactory(instanceIdentifier),\r\n                options\r\n            });\r\n            this.instances.set(instanceIdentifier, instance);\r\n            this.instancesOptions.set(instanceIdentifier, options);\r\n            /**\r\n             * Invoke onInit listeners.\r\n             * Note this.component.onInstanceCreated is different, which is used by the component creator,\r\n             * while onInit listeners are registered by consumers of the provider.\r\n             */\r\n            this.invokeOnInitCallbacks(instance, instanceIdentifier);\r\n            /**\r\n             * Order is important\r\n             * onInstanceCreated() should be called after this.instances.set(instanceIdentifier, instance); which\r\n             * makes `isInitialized()` return true.\r\n             */\r\n            if (this.component.onInstanceCreated) {\r\n                try {\r\n                    this.component.onInstanceCreated(this.container, instanceIdentifier, instance);\r\n                }\r\n                catch (_a) {\r\n                    // ignore errors in the onInstanceCreatedCallback\r\n                }\r\n            }\r\n        }\r\n        return instance || null;\r\n    }\r\n    normalizeInstanceIdentifier(identifier = DEFAULT_ENTRY_NAME) {\r\n        if (this.component) {\r\n            return this.component.multipleInstances ? identifier : DEFAULT_ENTRY_NAME;\r\n        }\r\n        else {\r\n            return identifier; // assume multiple instances are supported before the component is provided.\r\n        }\r\n    }\r\n    shouldAutoInitialize() {\r\n        return (!!this.component &&\r\n            this.component.instantiationMode !== \"EXPLICIT\" /* InstantiationMode.EXPLICIT */);\r\n    }\r\n}\r\n// undefined should be passed to the service factory for the default instance\r\nfunction normalizeIdentifierForFactory(identifier) {\r\n    return identifier === DEFAULT_ENTRY_NAME ? undefined : identifier;\r\n}\r\nfunction isComponentEager(component) {\r\n    return component.instantiationMode === \"EAGER\" /* InstantiationMode.EAGER */;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * ComponentContainer that provides Providers for service name T, e.g. `auth`, `auth-internal`\r\n */\r\nclass ComponentContainer {\r\n    constructor(name) {\r\n        this.name = name;\r\n        this.providers = new Map();\r\n    }\r\n    /**\r\n     *\r\n     * @param component Component being added\r\n     * @param overwrite When a component with the same name has already been registered,\r\n     * if overwrite is true: overwrite the existing component with the new component and create a new\r\n     * provider with the new component. It can be useful in tests where you want to use different mocks\r\n     * for different tests.\r\n     * if overwrite is false: throw an exception\r\n     */\r\n    addComponent(component) {\r\n        const provider = this.getProvider(component.name);\r\n        if (provider.isComponentSet()) {\r\n            throw new Error(`Component ${component.name} has already been registered with ${this.name}`);\r\n        }\r\n        provider.setComponent(component);\r\n    }\r\n    addOrOverwriteComponent(component) {\r\n        const provider = this.getProvider(component.name);\r\n        if (provider.isComponentSet()) {\r\n            // delete the existing provider from the container, so we can register the new component\r\n            this.providers.delete(component.name);\r\n        }\r\n        this.addComponent(component);\r\n    }\r\n    /**\r\n     * getProvider provides a type safe interface where it can only be called with a field name\r\n     * present in NameServiceMapping interface.\r\n     *\r\n     * Firebase SDKs providing services should extend NameServiceMapping interface to register\r\n     * themselves.\r\n     */\r\n    getProvider(name) {\r\n        if (this.providers.has(name)) {\r\n            return this.providers.get(name);\r\n        }\r\n        // create a Provider for a service that hasn't registered with Firebase\r\n        const provider = new Provider(name, this);\r\n        this.providers.set(name, provider);\r\n        return provider;\r\n    }\r\n    getProviders() {\r\n        return Array.from(this.providers.values());\r\n    }\r\n}\n\nexport { Component, ComponentContainer, Provider };\n//# sourceMappingURL=index.esm2017.js.map\n","import firebase from '@firebase/app-compat';\nimport { FirestoreError, Bytes, _isBase64Available, enableIndexedDbPersistence, enableMultiTabIndexedDbPersistence, clearIndexedDbPersistence, _DatabaseId, _logWarn, connectFirestoreEmulator, enableNetwork, disableNetwork, _validateIsNotUsedTogether, waitForPendingWrites, onSnapshotsInSync, collection, doc, collectionGroup, runTransaction, ensureFirestoreConfigured, WriteBatch as WriteBatch$1, executeWrite, loadBundle, namedQuery, DocumentSnapshot as DocumentSnapshot$1, DocumentReference as DocumentReference$1, _DocumentKey, refEqual, setDoc, updateDoc, deleteDoc, onSnapshot, getDocFromCache, getDocFromServer, getDoc, snapshotEqual, query, where, orderBy, limit, limitToLast, startAt, startAfter, endBefore, endAt, queryEqual, getDocsFromCache, getDocsFromServer, getDocs, QuerySnapshot as QuerySnapshot$1, addDoc, _cast, AbstractUserDataWriter, setLogLevel as setLogLevel$1, QueryDocumentSnapshot as QueryDocumentSnapshot$1, _debugAssert, FieldPath as FieldPath$1, _FieldPath, serverTimestamp, deleteField, arrayUnion, arrayRemove, increment, GeoPoint, Timestamp, CACHE_SIZE_UNLIMITED } from '@firebase/firestore';\nimport { getModularInstance } from '@firebase/util';\nimport { Component } from '@firebase/component';\n\nconst name = \"@firebase/firestore-compat\";\nconst version = \"0.3.18\";\n\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction validateSetOptions(methodName, options) {\r\n    if (options === undefined) {\r\n        return {\r\n            merge: false\r\n        };\r\n    }\r\n    if (options.mergeFields !== undefined && options.merge !== undefined) {\r\n        throw new FirestoreError('invalid-argument', `Invalid options passed to function ${methodName}(): You cannot ` +\r\n            'specify both \"merge\" and \"mergeFields\".');\r\n    }\r\n    return options;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/** Helper function to assert Uint8Array is available at runtime. */\r\nfunction assertUint8ArrayAvailable() {\r\n    if (typeof Uint8Array === 'undefined') {\r\n        throw new FirestoreError('unimplemented', 'Uint8Arrays are not available in this environment.');\r\n    }\r\n}\r\n/** Helper function to assert Base64 functions are available at runtime. */\r\nfunction assertBase64Available() {\r\n    if (!_isBase64Available()) {\r\n        throw new FirestoreError('unimplemented', 'Blobs are unavailable in Firestore in this environment.');\r\n    }\r\n}\r\n/** Immutable class holding a blob (binary data) */\r\nclass Blob {\r\n    constructor(_delegate) {\r\n        this._delegate = _delegate;\r\n    }\r\n    static fromBase64String(base64) {\r\n        assertBase64Available();\r\n        return new Blob(Bytes.fromBase64String(base64));\r\n    }\r\n    static fromUint8Array(array) {\r\n        assertUint8ArrayAvailable();\r\n        return new Blob(Bytes.fromUint8Array(array));\r\n    }\r\n    toBase64() {\r\n        assertBase64Available();\r\n        return this._delegate.toBase64();\r\n    }\r\n    toUint8Array() {\r\n        assertUint8ArrayAvailable();\r\n        return this._delegate.toUint8Array();\r\n    }\r\n    isEqual(other) {\r\n        return this._delegate.isEqual(other._delegate);\r\n    }\r\n    toString() {\r\n        return 'Blob(base64: ' + this.toBase64() + ')';\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction isPartialObserver(obj) {\r\n    return implementsAnyMethods(obj, ['next', 'error', 'complete']);\r\n}\r\n/**\r\n * Returns true if obj is an object and contains at least one of the specified\r\n * methods.\r\n */\r\nfunction implementsAnyMethods(obj, methods) {\r\n    if (typeof obj !== 'object' || obj === null) {\r\n        return false;\r\n    }\r\n    const object = obj;\r\n    for (const method of methods) {\r\n        if (method in object && typeof object[method] === 'function') {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * The persistence provider included with the full Firestore SDK.\r\n */\r\nclass IndexedDbPersistenceProvider {\r\n    enableIndexedDbPersistence(firestore, forceOwnership) {\r\n        return enableIndexedDbPersistence(firestore._delegate, { forceOwnership });\r\n    }\r\n    enableMultiTabIndexedDbPersistence(firestore) {\r\n        return enableMultiTabIndexedDbPersistence(firestore._delegate);\r\n    }\r\n    clearIndexedDbPersistence(firestore) {\r\n        return clearIndexedDbPersistence(firestore._delegate);\r\n    }\r\n}\r\n/**\r\n * Compat class for Firestore. Exposes Firestore Legacy API, but delegates\r\n * to the functional API of firestore-exp.\r\n */\r\nclass Firestore {\r\n    constructor(databaseIdOrApp, _delegate, _persistenceProvider) {\r\n        this._delegate = _delegate;\r\n        this._persistenceProvider = _persistenceProvider;\r\n        this.INTERNAL = {\r\n            delete: () => this.terminate()\r\n        };\r\n        if (!(databaseIdOrApp instanceof _DatabaseId)) {\r\n            this._appCompat = databaseIdOrApp;\r\n        }\r\n    }\r\n    get _databaseId() {\r\n        return this._delegate._databaseId;\r\n    }\r\n    settings(settingsLiteral) {\r\n        const currentSettings = this._delegate._getSettings();\r\n        if (!settingsLiteral.merge &&\r\n            currentSettings.host !== settingsLiteral.host) {\r\n            _logWarn('You are overriding the original host. If you did not intend ' +\r\n                'to override your settings, use {merge: true}.');\r\n        }\r\n        if (settingsLiteral.merge) {\r\n            settingsLiteral = Object.assign(Object.assign({}, currentSettings), settingsLiteral);\r\n            // Remove the property from the settings once the merge is completed\r\n            delete settingsLiteral.merge;\r\n        }\r\n        this._delegate._setSettings(settingsLiteral);\r\n    }\r\n    useEmulator(host, port, options = {}) {\r\n        connectFirestoreEmulator(this._delegate, host, port, options);\r\n    }\r\n    enableNetwork() {\r\n        return enableNetwork(this._delegate);\r\n    }\r\n    disableNetwork() {\r\n        return disableNetwork(this._delegate);\r\n    }\r\n    enablePersistence(settings) {\r\n        let synchronizeTabs = false;\r\n        let experimentalForceOwningTab = false;\r\n        if (settings) {\r\n            synchronizeTabs = !!settings.synchronizeTabs;\r\n            experimentalForceOwningTab = !!settings.experimentalForceOwningTab;\r\n            _validateIsNotUsedTogether('synchronizeTabs', synchronizeTabs, 'experimentalForceOwningTab', experimentalForceOwningTab);\r\n        }\r\n        return synchronizeTabs\r\n            ? this._persistenceProvider.enableMultiTabIndexedDbPersistence(this)\r\n            : this._persistenceProvider.enableIndexedDbPersistence(this, experimentalForceOwningTab);\r\n    }\r\n    clearPersistence() {\r\n        return this._persistenceProvider.clearIndexedDbPersistence(this);\r\n    }\r\n    terminate() {\r\n        if (this._appCompat) {\r\n            this._appCompat._removeServiceInstance('firestore-compat');\r\n            this._appCompat._removeServiceInstance('firestore');\r\n        }\r\n        return this._delegate._delete();\r\n    }\r\n    waitForPendingWrites() {\r\n        return waitForPendingWrites(this._delegate);\r\n    }\r\n    onSnapshotsInSync(arg) {\r\n        return onSnapshotsInSync(this._delegate, arg);\r\n    }\r\n    get app() {\r\n        if (!this._appCompat) {\r\n            throw new FirestoreError('failed-precondition', \"Firestore was not initialized using the Firebase SDK. 'app' is \" +\r\n                'not available');\r\n        }\r\n        return this._appCompat;\r\n    }\r\n    collection(pathString) {\r\n        try {\r\n            return new CollectionReference(this, collection(this._delegate, pathString));\r\n        }\r\n        catch (e) {\r\n            throw replaceFunctionName(e, 'collection()', 'Firestore.collection()');\r\n        }\r\n    }\r\n    doc(pathString) {\r\n        try {\r\n            return new DocumentReference(this, doc(this._delegate, pathString));\r\n        }\r\n        catch (e) {\r\n            throw replaceFunctionName(e, 'doc()', 'Firestore.doc()');\r\n        }\r\n    }\r\n    collectionGroup(collectionId) {\r\n        try {\r\n            return new Query(this, collectionGroup(this._delegate, collectionId));\r\n        }\r\n        catch (e) {\r\n            throw replaceFunctionName(e, 'collectionGroup()', 'Firestore.collectionGroup()');\r\n        }\r\n    }\r\n    runTransaction(updateFunction) {\r\n        return runTransaction(this._delegate, transaction => updateFunction(new Transaction(this, transaction)));\r\n    }\r\n    batch() {\r\n        ensureFirestoreConfigured(this._delegate);\r\n        return new WriteBatch(new WriteBatch$1(this._delegate, mutations => executeWrite(this._delegate, mutations)));\r\n    }\r\n    loadBundle(bundleData) {\r\n        return loadBundle(this._delegate, bundleData);\r\n    }\r\n    namedQuery(name) {\r\n        return namedQuery(this._delegate, name).then(expQuery => {\r\n            if (!expQuery) {\r\n                return null;\r\n            }\r\n            return new Query(this, \r\n            // We can pass `expQuery` here directly since named queries don't have a UserDataConverter.\r\n            // Otherwise, we would have to create a new ExpQuery and pass the old UserDataConverter.\r\n            expQuery);\r\n        });\r\n    }\r\n}\r\nclass UserDataWriter extends AbstractUserDataWriter {\r\n    constructor(firestore) {\r\n        super();\r\n        this.firestore = firestore;\r\n    }\r\n    convertBytes(bytes) {\r\n        return new Blob(new Bytes(bytes));\r\n    }\r\n    convertReference(name) {\r\n        const key = this.convertDocumentKey(name, this.firestore._databaseId);\r\n        return DocumentReference.forKey(key, this.firestore, /* converter= */ null);\r\n    }\r\n}\r\nfunction setLogLevel(level) {\r\n    setLogLevel$1(level);\r\n}\r\n/**\r\n * A reference to a transaction.\r\n */\r\nclass Transaction {\r\n    constructor(_firestore, _delegate) {\r\n        this._firestore = _firestore;\r\n        this._delegate = _delegate;\r\n        this._userDataWriter = new UserDataWriter(_firestore);\r\n    }\r\n    get(documentRef) {\r\n        const ref = castReference(documentRef);\r\n        return this._delegate\r\n            .get(ref)\r\n            .then(result => new DocumentSnapshot(this._firestore, new DocumentSnapshot$1(this._firestore._delegate, this._userDataWriter, result._key, result._document, result.metadata, ref.converter)));\r\n    }\r\n    set(documentRef, data, options) {\r\n        const ref = castReference(documentRef);\r\n        if (options) {\r\n            validateSetOptions('Transaction.set', options);\r\n            this._delegate.set(ref, data, options);\r\n        }\r\n        else {\r\n            this._delegate.set(ref, data);\r\n        }\r\n        return this;\r\n    }\r\n    update(documentRef, dataOrField, value, ...moreFieldsAndValues) {\r\n        const ref = castReference(documentRef);\r\n        if (arguments.length === 2) {\r\n            this._delegate.update(ref, dataOrField);\r\n        }\r\n        else {\r\n            this._delegate.update(ref, dataOrField, value, ...moreFieldsAndValues);\r\n        }\r\n        return this;\r\n    }\r\n    delete(documentRef) {\r\n        const ref = castReference(documentRef);\r\n        this._delegate.delete(ref);\r\n        return this;\r\n    }\r\n}\r\nclass WriteBatch {\r\n    constructor(_delegate) {\r\n        this._delegate = _delegate;\r\n    }\r\n    set(documentRef, data, options) {\r\n        const ref = castReference(documentRef);\r\n        if (options) {\r\n            validateSetOptions('WriteBatch.set', options);\r\n            this._delegate.set(ref, data, options);\r\n        }\r\n        else {\r\n            this._delegate.set(ref, data);\r\n        }\r\n        return this;\r\n    }\r\n    update(documentRef, dataOrField, value, ...moreFieldsAndValues) {\r\n        const ref = castReference(documentRef);\r\n        if (arguments.length === 2) {\r\n            this._delegate.update(ref, dataOrField);\r\n        }\r\n        else {\r\n            this._delegate.update(ref, dataOrField, value, ...moreFieldsAndValues);\r\n        }\r\n        return this;\r\n    }\r\n    delete(documentRef) {\r\n        const ref = castReference(documentRef);\r\n        this._delegate.delete(ref);\r\n        return this;\r\n    }\r\n    commit() {\r\n        return this._delegate.commit();\r\n    }\r\n}\r\n/**\r\n * Wraps a `PublicFirestoreDataConverter` translating the types from the\r\n * experimental SDK into corresponding types from the Classic SDK before passing\r\n * them to the wrapped converter.\r\n */\r\nclass FirestoreDataConverter {\r\n    constructor(_firestore, _userDataWriter, _delegate) {\r\n        this._firestore = _firestore;\r\n        this._userDataWriter = _userDataWriter;\r\n        this._delegate = _delegate;\r\n    }\r\n    fromFirestore(snapshot, options) {\r\n        const expSnapshot = new QueryDocumentSnapshot$1(this._firestore._delegate, this._userDataWriter, snapshot._key, snapshot._document, snapshot.metadata, \r\n        /* converter= */ null);\r\n        return this._delegate.fromFirestore(new QueryDocumentSnapshot(this._firestore, expSnapshot), options !== null && options !== void 0 ? options : {});\r\n    }\r\n    toFirestore(modelObject, options) {\r\n        if (!options) {\r\n            return this._delegate.toFirestore(modelObject);\r\n        }\r\n        else {\r\n            return this._delegate.toFirestore(modelObject, options);\r\n        }\r\n    }\r\n    // Use the same instance of `FirestoreDataConverter` for the given instances\r\n    // of `Firestore` and `PublicFirestoreDataConverter` so that isEqual() will\r\n    // compare equal for two objects created with the same converter instance.\r\n    static getInstance(firestore, converter) {\r\n        const converterMapByFirestore = FirestoreDataConverter.INSTANCES;\r\n        let untypedConverterByConverter = converterMapByFirestore.get(firestore);\r\n        if (!untypedConverterByConverter) {\r\n            untypedConverterByConverter = new WeakMap();\r\n            converterMapByFirestore.set(firestore, untypedConverterByConverter);\r\n        }\r\n        let instance = untypedConverterByConverter.get(converter);\r\n        if (!instance) {\r\n            instance = new FirestoreDataConverter(firestore, new UserDataWriter(firestore), converter);\r\n            untypedConverterByConverter.set(converter, instance);\r\n        }\r\n        return instance;\r\n    }\r\n}\r\nFirestoreDataConverter.INSTANCES = new WeakMap();\r\n/**\r\n * A reference to a particular document in a collection in the database.\r\n */\r\nclass DocumentReference {\r\n    constructor(firestore, _delegate) {\r\n        this.firestore = firestore;\r\n        this._delegate = _delegate;\r\n        this._userDataWriter = new UserDataWriter(firestore);\r\n    }\r\n    static forPath(path, firestore, converter) {\r\n        if (path.length % 2 !== 0) {\r\n            throw new FirestoreError('invalid-argument', 'Invalid document reference. Document ' +\r\n                'references must have an even number of segments, but ' +\r\n                `${path.canonicalString()} has ${path.length}`);\r\n        }\r\n        return new DocumentReference(firestore, new DocumentReference$1(firestore._delegate, converter, new _DocumentKey(path)));\r\n    }\r\n    static forKey(key, firestore, converter) {\r\n        return new DocumentReference(firestore, new DocumentReference$1(firestore._delegate, converter, key));\r\n    }\r\n    get id() {\r\n        return this._delegate.id;\r\n    }\r\n    get parent() {\r\n        return new CollectionReference(this.firestore, this._delegate.parent);\r\n    }\r\n    get path() {\r\n        return this._delegate.path;\r\n    }\r\n    collection(pathString) {\r\n        try {\r\n            return new CollectionReference(this.firestore, collection(this._delegate, pathString));\r\n        }\r\n        catch (e) {\r\n            throw replaceFunctionName(e, 'collection()', 'DocumentReference.collection()');\r\n        }\r\n    }\r\n    isEqual(other) {\r\n        other = getModularInstance(other);\r\n        if (!(other instanceof DocumentReference$1)) {\r\n            return false;\r\n        }\r\n        return refEqual(this._delegate, other);\r\n    }\r\n    set(value, options) {\r\n        options = validateSetOptions('DocumentReference.set', options);\r\n        try {\r\n            if (options) {\r\n                return setDoc(this._delegate, value, options);\r\n            }\r\n            else {\r\n                return setDoc(this._delegate, value);\r\n            }\r\n        }\r\n        catch (e) {\r\n            throw replaceFunctionName(e, 'setDoc()', 'DocumentReference.set()');\r\n        }\r\n    }\r\n    update(fieldOrUpdateData, value, ...moreFieldsAndValues) {\r\n        try {\r\n            if (arguments.length === 1) {\r\n                return updateDoc(this._delegate, fieldOrUpdateData);\r\n            }\r\n            else {\r\n                return updateDoc(this._delegate, fieldOrUpdateData, value, ...moreFieldsAndValues);\r\n            }\r\n        }\r\n        catch (e) {\r\n            throw replaceFunctionName(e, 'updateDoc()', 'DocumentReference.update()');\r\n        }\r\n    }\r\n    delete() {\r\n        return deleteDoc(this._delegate);\r\n    }\r\n    onSnapshot(...args) {\r\n        const options = extractSnapshotOptions(args);\r\n        const observer = wrapObserver(args, result => new DocumentSnapshot(this.firestore, new DocumentSnapshot$1(this.firestore._delegate, this._userDataWriter, result._key, result._document, result.metadata, this._delegate.converter)));\r\n        return onSnapshot(this._delegate, options, observer);\r\n    }\r\n    get(options) {\r\n        let snap;\r\n        if ((options === null || options === void 0 ? void 0 : options.source) === 'cache') {\r\n            snap = getDocFromCache(this._delegate);\r\n        }\r\n        else if ((options === null || options === void 0 ? void 0 : options.source) === 'server') {\r\n            snap = getDocFromServer(this._delegate);\r\n        }\r\n        else {\r\n            snap = getDoc(this._delegate);\r\n        }\r\n        return snap.then(result => new DocumentSnapshot(this.firestore, new DocumentSnapshot$1(this.firestore._delegate, this._userDataWriter, result._key, result._document, result.metadata, this._delegate.converter)));\r\n    }\r\n    withConverter(converter) {\r\n        return new DocumentReference(this.firestore, converter\r\n            ? this._delegate.withConverter(FirestoreDataConverter.getInstance(this.firestore, converter))\r\n            : this._delegate.withConverter(null));\r\n    }\r\n}\r\n/**\r\n * Replaces the function name in an error thrown by the firestore-exp API\r\n * with the function names used in the classic API.\r\n */\r\nfunction replaceFunctionName(e, original, updated) {\r\n    e.message = e.message.replace(original, updated);\r\n    return e;\r\n}\r\n/**\r\n * Iterates the list of arguments from an `onSnapshot` call and returns the\r\n * first argument that may be an `SnapshotListenOptions` object. Returns an\r\n * empty object if none is found.\r\n */\r\nfunction extractSnapshotOptions(args) {\r\n    for (const arg of args) {\r\n        if (typeof arg === 'object' && !isPartialObserver(arg)) {\r\n            return arg;\r\n        }\r\n    }\r\n    return {};\r\n}\r\n/**\r\n * Creates an observer that can be passed to the firestore-exp SDK. The\r\n * observer converts all observed values into the format expected by the classic\r\n * SDK.\r\n *\r\n * @param args - The list of arguments from an `onSnapshot` call.\r\n * @param wrapper - The function that converts the firestore-exp type into the\r\n * type used by this shim.\r\n */\r\nfunction wrapObserver(args, wrapper) {\r\n    var _a, _b;\r\n    let userObserver;\r\n    if (isPartialObserver(args[0])) {\r\n        userObserver = args[0];\r\n    }\r\n    else if (isPartialObserver(args[1])) {\r\n        userObserver = args[1];\r\n    }\r\n    else if (typeof args[0] === 'function') {\r\n        userObserver = {\r\n            next: args[0],\r\n            error: args[1],\r\n            complete: args[2]\r\n        };\r\n    }\r\n    else {\r\n        userObserver = {\r\n            next: args[1],\r\n            error: args[2],\r\n            complete: args[3]\r\n        };\r\n    }\r\n    return {\r\n        next: val => {\r\n            if (userObserver.next) {\r\n                userObserver.next(wrapper(val));\r\n            }\r\n        },\r\n        error: (_a = userObserver.error) === null || _a === void 0 ? void 0 : _a.bind(userObserver),\r\n        complete: (_b = userObserver.complete) === null || _b === void 0 ? void 0 : _b.bind(userObserver)\r\n    };\r\n}\r\nclass DocumentSnapshot {\r\n    constructor(_firestore, _delegate) {\r\n        this._firestore = _firestore;\r\n        this._delegate = _delegate;\r\n    }\r\n    get ref() {\r\n        return new DocumentReference(this._firestore, this._delegate.ref);\r\n    }\r\n    get id() {\r\n        return this._delegate.id;\r\n    }\r\n    get metadata() {\r\n        return this._delegate.metadata;\r\n    }\r\n    get exists() {\r\n        return this._delegate.exists();\r\n    }\r\n    data(options) {\r\n        return this._delegate.data(options);\r\n    }\r\n    get(fieldPath, options\r\n    // We are using `any` here to avoid an explicit cast by our users.\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    ) {\r\n        return this._delegate.get(fieldPath, options);\r\n    }\r\n    isEqual(other) {\r\n        return snapshotEqual(this._delegate, other._delegate);\r\n    }\r\n}\r\nclass QueryDocumentSnapshot extends DocumentSnapshot {\r\n    data(options) {\r\n        const data = this._delegate.data(options);\r\n        _debugAssert(data !== undefined, 'Document in a QueryDocumentSnapshot should exist');\r\n        return data;\r\n    }\r\n}\r\nclass Query {\r\n    constructor(firestore, _delegate) {\r\n        this.firestore = firestore;\r\n        this._delegate = _delegate;\r\n        this._userDataWriter = new UserDataWriter(firestore);\r\n    }\r\n    where(fieldPath, opStr, value) {\r\n        try {\r\n            // The \"as string\" cast is a little bit of a hack. `where` accepts the\r\n            // FieldPath Compat type as input, but is not typed as such in order to\r\n            // not expose this via our public typings file.\r\n            return new Query(this.firestore, query(this._delegate, where(fieldPath, opStr, value)));\r\n        }\r\n        catch (e) {\r\n            throw replaceFunctionName(e, /(orderBy|where)\\(\\)/, 'Query.$1()');\r\n        }\r\n    }\r\n    orderBy(fieldPath, directionStr) {\r\n        try {\r\n            // The \"as string\" cast is a little bit of a hack. `orderBy` accepts the\r\n            // FieldPath Compat type as input, but is not typed as such in order to\r\n            // not expose this via our public typings file.\r\n            return new Query(this.firestore, query(this._delegate, orderBy(fieldPath, directionStr)));\r\n        }\r\n        catch (e) {\r\n            throw replaceFunctionName(e, /(orderBy|where)\\(\\)/, 'Query.$1()');\r\n        }\r\n    }\r\n    limit(n) {\r\n        try {\r\n            return new Query(this.firestore, query(this._delegate, limit(n)));\r\n        }\r\n        catch (e) {\r\n            throw replaceFunctionName(e, 'limit()', 'Query.limit()');\r\n        }\r\n    }\r\n    limitToLast(n) {\r\n        try {\r\n            return new Query(this.firestore, query(this._delegate, limitToLast(n)));\r\n        }\r\n        catch (e) {\r\n            throw replaceFunctionName(e, 'limitToLast()', 'Query.limitToLast()');\r\n        }\r\n    }\r\n    startAt(...args) {\r\n        try {\r\n            return new Query(this.firestore, query(this._delegate, startAt(...args)));\r\n        }\r\n        catch (e) {\r\n            throw replaceFunctionName(e, 'startAt()', 'Query.startAt()');\r\n        }\r\n    }\r\n    startAfter(...args) {\r\n        try {\r\n            return new Query(this.firestore, query(this._delegate, startAfter(...args)));\r\n        }\r\n        catch (e) {\r\n            throw replaceFunctionName(e, 'startAfter()', 'Query.startAfter()');\r\n        }\r\n    }\r\n    endBefore(...args) {\r\n        try {\r\n            return new Query(this.firestore, query(this._delegate, endBefore(...args)));\r\n        }\r\n        catch (e) {\r\n            throw replaceFunctionName(e, 'endBefore()', 'Query.endBefore()');\r\n        }\r\n    }\r\n    endAt(...args) {\r\n        try {\r\n            return new Query(this.firestore, query(this._delegate, endAt(...args)));\r\n        }\r\n        catch (e) {\r\n            throw replaceFunctionName(e, 'endAt()', 'Query.endAt()');\r\n        }\r\n    }\r\n    isEqual(other) {\r\n        return queryEqual(this._delegate, other._delegate);\r\n    }\r\n    get(options) {\r\n        let query;\r\n        if ((options === null || options === void 0 ? void 0 : options.source) === 'cache') {\r\n            query = getDocsFromCache(this._delegate);\r\n        }\r\n        else if ((options === null || options === void 0 ? void 0 : options.source) === 'server') {\r\n            query = getDocsFromServer(this._delegate);\r\n        }\r\n        else {\r\n            query = getDocs(this._delegate);\r\n        }\r\n        return query.then(result => new QuerySnapshot(this.firestore, new QuerySnapshot$1(this.firestore._delegate, this._userDataWriter, this._delegate, result._snapshot)));\r\n    }\r\n    onSnapshot(...args) {\r\n        const options = extractSnapshotOptions(args);\r\n        const observer = wrapObserver(args, snap => new QuerySnapshot(this.firestore, new QuerySnapshot$1(this.firestore._delegate, this._userDataWriter, this._delegate, snap._snapshot)));\r\n        return onSnapshot(this._delegate, options, observer);\r\n    }\r\n    withConverter(converter) {\r\n        return new Query(this.firestore, converter\r\n            ? this._delegate.withConverter(FirestoreDataConverter.getInstance(this.firestore, converter))\r\n            : this._delegate.withConverter(null));\r\n    }\r\n}\r\nclass DocumentChange {\r\n    constructor(_firestore, _delegate) {\r\n        this._firestore = _firestore;\r\n        this._delegate = _delegate;\r\n    }\r\n    get type() {\r\n        return this._delegate.type;\r\n    }\r\n    get doc() {\r\n        return new QueryDocumentSnapshot(this._firestore, this._delegate.doc);\r\n    }\r\n    get oldIndex() {\r\n        return this._delegate.oldIndex;\r\n    }\r\n    get newIndex() {\r\n        return this._delegate.newIndex;\r\n    }\r\n}\r\nclass QuerySnapshot {\r\n    constructor(_firestore, _delegate) {\r\n        this._firestore = _firestore;\r\n        this._delegate = _delegate;\r\n    }\r\n    get query() {\r\n        return new Query(this._firestore, this._delegate.query);\r\n    }\r\n    get metadata() {\r\n        return this._delegate.metadata;\r\n    }\r\n    get size() {\r\n        return this._delegate.size;\r\n    }\r\n    get empty() {\r\n        return this._delegate.empty;\r\n    }\r\n    get docs() {\r\n        return this._delegate.docs.map(doc => new QueryDocumentSnapshot(this._firestore, doc));\r\n    }\r\n    docChanges(options) {\r\n        return this._delegate\r\n            .docChanges(options)\r\n            .map(docChange => new DocumentChange(this._firestore, docChange));\r\n    }\r\n    forEach(callback, thisArg) {\r\n        this._delegate.forEach(snapshot => {\r\n            callback.call(thisArg, new QueryDocumentSnapshot(this._firestore, snapshot));\r\n        });\r\n    }\r\n    isEqual(other) {\r\n        return snapshotEqual(this._delegate, other._delegate);\r\n    }\r\n}\r\nclass CollectionReference extends Query {\r\n    constructor(firestore, _delegate) {\r\n        super(firestore, _delegate);\r\n        this.firestore = firestore;\r\n        this._delegate = _delegate;\r\n    }\r\n    get id() {\r\n        return this._delegate.id;\r\n    }\r\n    get path() {\r\n        return this._delegate.path;\r\n    }\r\n    get parent() {\r\n        const docRef = this._delegate.parent;\r\n        return docRef ? new DocumentReference(this.firestore, docRef) : null;\r\n    }\r\n    doc(documentPath) {\r\n        try {\r\n            if (documentPath === undefined) {\r\n                // Call `doc` without `documentPath` if `documentPath` is `undefined`\r\n                // as `doc` validates the number of arguments to prevent users from\r\n                // accidentally passing `undefined`.\r\n                return new DocumentReference(this.firestore, doc(this._delegate));\r\n            }\r\n            else {\r\n                return new DocumentReference(this.firestore, doc(this._delegate, documentPath));\r\n            }\r\n        }\r\n        catch (e) {\r\n            throw replaceFunctionName(e, 'doc()', 'CollectionReference.doc()');\r\n        }\r\n    }\r\n    add(data) {\r\n        return addDoc(this._delegate, data).then(docRef => new DocumentReference(this.firestore, docRef));\r\n    }\r\n    isEqual(other) {\r\n        return refEqual(this._delegate, other._delegate);\r\n    }\r\n    withConverter(converter) {\r\n        return new CollectionReference(this.firestore, converter\r\n            ? this._delegate.withConverter(FirestoreDataConverter.getInstance(this.firestore, converter))\r\n            : this._delegate.withConverter(null));\r\n    }\r\n}\r\nfunction castReference(documentRef) {\r\n    return _cast(documentRef, DocumentReference$1);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n// The objects that are a part of this API are exposed to third-parties as\r\n// compiled javascript so we want to flag our private members with a leading\r\n// underscore to discourage their use.\r\n/**\r\n * A `FieldPath` refers to a field in a document. The path may consist of a\r\n * single field name (referring to a top-level field in the document), or a list\r\n * of field names (referring to a nested field in the document).\r\n */\r\nclass FieldPath {\r\n    /**\r\n     * Creates a FieldPath from the provided field names. If more than one field\r\n     * name is provided, the path will point to a nested field in a document.\r\n     *\r\n     * @param fieldNames - A list of field names.\r\n     */\r\n    constructor(...fieldNames) {\r\n        this._delegate = new FieldPath$1(...fieldNames);\r\n    }\r\n    static documentId() {\r\n        /**\r\n         * Internal Note: The backend doesn't technically support querying by\r\n         * document ID. Instead it queries by the entire document name (full path\r\n         * included), but in the cases we currently support documentId(), the net\r\n         * effect is the same.\r\n         */\r\n        return new FieldPath(_FieldPath.keyField().canonicalString());\r\n    }\r\n    isEqual(other) {\r\n        other = getModularInstance(other);\r\n        if (!(other instanceof FieldPath$1)) {\r\n            return false;\r\n        }\r\n        return this._delegate._internalPath.isEqual(other._internalPath);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass FieldValue {\r\n    constructor(_delegate) {\r\n        this._delegate = _delegate;\r\n    }\r\n    static serverTimestamp() {\r\n        const delegate = serverTimestamp();\r\n        delegate._methodName = 'FieldValue.serverTimestamp';\r\n        return new FieldValue(delegate);\r\n    }\r\n    static delete() {\r\n        const delegate = deleteField();\r\n        delegate._methodName = 'FieldValue.delete';\r\n        return new FieldValue(delegate);\r\n    }\r\n    static arrayUnion(...elements) {\r\n        const delegate = arrayUnion(...elements);\r\n        delegate._methodName = 'FieldValue.arrayUnion';\r\n        return new FieldValue(delegate);\r\n    }\r\n    static arrayRemove(...elements) {\r\n        const delegate = arrayRemove(...elements);\r\n        delegate._methodName = 'FieldValue.arrayRemove';\r\n        return new FieldValue(delegate);\r\n    }\r\n    static increment(n) {\r\n        const delegate = increment(n);\r\n        delegate._methodName = 'FieldValue.increment';\r\n        return new FieldValue(delegate);\r\n    }\r\n    isEqual(other) {\r\n        return this._delegate.isEqual(other._delegate);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst firestoreNamespace = {\r\n    Firestore,\r\n    GeoPoint,\r\n    Timestamp,\r\n    Blob,\r\n    Transaction,\r\n    WriteBatch,\r\n    DocumentReference,\r\n    DocumentSnapshot,\r\n    Query,\r\n    QueryDocumentSnapshot,\r\n    QuerySnapshot,\r\n    CollectionReference,\r\n    FieldPath,\r\n    FieldValue,\r\n    setLogLevel,\r\n    CACHE_SIZE_UNLIMITED\r\n};\r\n/**\r\n * Configures Firestore as part of the Firebase SDK by calling registerComponent.\r\n *\r\n * @param firebase - The FirebaseNamespace to register Firestore with\r\n * @param firestoreFactory - A factory function that returns a new Firestore\r\n *    instance.\r\n */\r\nfunction configureForFirebase(firebase, firestoreFactory) {\r\n    firebase.INTERNAL.registerComponent(new Component('firestore-compat', container => {\r\n        const app = container.getProvider('app-compat').getImmediate();\r\n        const firestoreExp = container.getProvider('firestore').getImmediate();\r\n        return firestoreFactory(app, firestoreExp);\r\n    }, 'PUBLIC').setServiceProps(Object.assign({}, firestoreNamespace)));\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Registers the main Firestore build with the components framework.\r\n * Persistence can be enabled via `firebase.firestore().enablePersistence()`.\r\n */\r\nfunction registerFirestore(instance) {\r\n    configureForFirebase(instance, (app, firestoreExp) => new Firestore(app, firestoreExp, new IndexedDbPersistenceProvider()));\r\n    instance.registerVersion(name, version);\r\n}\r\nregisterFirestore(firebase);\n\nexport { registerFirestore };\n//# sourceMappingURL=index.esm2017.js.map\n"],"sourceRoot":""}